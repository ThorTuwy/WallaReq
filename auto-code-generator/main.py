import tomllib
import json
import os
import copy
import subprocess
from pathlib import Path

from datamodel_code_generator import InputFileType, generate
from datamodel_code_generator import DataModelType

dataDirectory = "../backend/data"
templatesDirectoryBack = "../backend/dataTemplates"
templatesDirectoryFront = "../frontend/src/templates"
autoGeneratedTypesDirectory = "../frontend/src/auto-generated-types"
configsDirectory = "./configs"
json2ts = "../frontend/node_modules/.bin/json2ts"

configsFileName = ["configs", "topicsToCheck"]
TOML_configs = []

for name in configsFileName:
    TOML_configs.append(os.path.join(configsDirectory, name + ".toml"))

configs = []
for file in TOML_configs:
    with open(file, "rb") as f:
        configs.append(tomllib.load(f))


def recursiveEmptyConfigMaker(configs, new):
    # Base case
    if "type" in configs:
        if "defaultValue" in configs:
            new = configs["defaultValue"]

        else:
            match configs["type"]:
                case "text" | "select":
                    new = ""
                case "number":
                    new = 0
                case "checkbox":
                    new = False
                case "stringArray":
                    new = []
                case "objectsArray":
                    new = []
                case _:
                    raise ValueError("Not a valid type")

        return new

    for key, value in configs.items():
        new.setdefault(key, {})
        newValue = recursiveEmptyConfigMaker(value, new[key])
        if newValue is not None:
            new[key] = newValue

    return None


emptyConfigs = []
for config in configs:
    configDic = {}
    recursiveEmptyConfigMaker(config, configDic)

    emptyConfigs.append(configDic)


# 1º Write the empty configs as files
def writeEmptyConfigs(fileName, emptyConfig):
    for i in range(len(configsFileName)):
        with open(
            os.path.join(templatesDirectoryBack, f"template_{fileName}.json"), "w"
        ) as f:
            json.dump(emptyConfig, f, indent=4)


for i in range(len(configsFileName)):
    writeEmptyConfigs(configsFileName[i], emptyConfigs[i])


# 2º Check if the actual configs files are valid
def verifyData(fileName):
    file = os.path.join(dataDirectory, fileName + ".json")

    try:
        with open(file) as f:
            json.load(f)
    # If we can not load the file, this means is not valid/missing
    except Exception:
        toDump = {}
        if dataName == "configs":
            toDump = emptyConfigs[0] #TODO Remove order matters
        with open(file, "w") as f:
            json.dump(toDump, f, indent=4)


for dataName in ["configs", "topicsToCheck", "uploadAlready"]:
    verifyData(dataName)


typeDict = {
    "text": "string",
    "number": "number",
    "checkbox": "boolean",
    "stringArray": "array",
    "select": "string",
}


def recursiveConfigsToJSONSchema(configs) -> None:
    print(configs)
    if isinstance(configs, dict):
        typeOfObject = "object"
        if "type" in configs and configs["type"] == "objectsArray":
            del configs["type"]
            typeOfObject = "array"

        toIterateConfigs = copy.deepcopy(configs)

        if typeOfObject == "array":
            configs["items"] = {}
            configs["items"]["properties"] = {}
            configs["items"]["type"] = "object"
            configs["type"] = "array"

        else:
            configs["properties"] = {}
            configs["type"] = "object"

        for index, value in (toIterateConfigs).items():
            if "type" in value and value["type"] != "objectsArray":
                valueType = value["type"]

                value = {"type": typeDict[valueType], "description": value["textLabel"]}

                if valueType == "stringArray":
                    value["items"] = {"type": "string"}
            else:
                recursiveConfigsToJSONSchema(value)

            del configs[index]

            if typeOfObject == "array":
                configs["items"]["properties"][index] = value
            else:
                configs["properties"][index] = value

    else:
        raise ValueError("Recursion was made on a non-dict object")


configsJSONSchema = []
for i in range(len(configsFileName)):
    print("Config: ", configsFileName[i])
    print(configs[i])
    configDic = copy.deepcopy(configs[i])

    recursiveConfigsToJSONSchema(configDic)

    configDic["title"] = configsFileName[i]
    configDic["$schema"] = "http://json-schema.org/draft-07/schema#"

    configsJSONSchema.append(configDic)


# 3º Generate the python models (Using JsonSchema)
def updateModels(fileName, ConfigJsonSchema):
    pythonModel = Path(templatesDirectoryBack, f"{fileName}_model.py")

    generate(
        json.dumps(ConfigJsonSchema),
        input_file_type=InputFileType.JsonSchema,
        input_filename=f"{fileName}.json",
        output=pythonModel,
        output_model_type=DataModelType.PydanticV2BaseModel,
    )


for i in range(len(configsFileName)):
    updateModels(configsFileName[i], configsJSONSchema[i])

#
# Front end
#


# 1º Copy configs as JSON
def copyConfigsAsJSON(fileName,config):
    with open(
        os.path.join(templatesDirectoryFront, f"template_{fileName}.json"), "w"
    ) as f:
        json.dump(config, f, indent=4)


for i in range(len(configsFileName)):
    copyConfigsAsJSON(configsFileName[i],configs[i])


# 2º Copy jsonSchemas as JSON
def copyJSONSchemasAsJSON(fileName, configJSONSchema):
    with open(
        os.path.join(autoGeneratedTypesDirectory, f"schema_{fileName}.json"), "w"
    ) as f:
        json.dump(configJSONSchema, f, indent=4)


for i in range(len(configsFileName)):
    copyJSONSchemasAsJSON(configsFileName[i], configsJSONSchema[i])


# 3º Generate the typescript interfaces (Using JsonSchema)
def makeInterfaces(fileName):
    print(
        os.path.join(autoGeneratedTypesDirectory, f"schema_{fileName}.json"),
    )
    subprocess.run(
        [
            json2ts,
            "--input",
            os.path.join(autoGeneratedTypesDirectory, f"schema_{fileName}.json"),
            "--output",
            os.path.join(autoGeneratedTypesDirectory, f"{fileName}.d.ts"),
        ]
    )


for i in range(len(configsFileName)):
    makeInterfaces(configsFileName[i])
